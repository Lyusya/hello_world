#Структуры данных

название классов, интерфейсов | описание  | время получения | время добавления | область применимости | наследуется от
------------ | --------------------- | ---- | ---- | --------------- | --------------
"interface" Collection | Корень, основной класс в иерархии. Коллекция содержит набор объектов (элементов). Этот интерфейс реализуют все типы коллекций и его можно использовать как тип объекта, если требуется максимальное обобщение. Некоторые типы унаследованые от Collection позволяют добавлять одинаковые элементы, некоторые нет. Они также бывают упорядоченные и неупорядоченные. Java не содержит прямых реализаций этого типа, но зато есть множество реализаций его дочерних интерфейсов. | | | | 
"interface" Set | Коллекция, не содержащая одинаковых элементов. Коллекция воплощает математическую модель множества. Может быть использовано для содержания набора игральных карт в руке, предметов в расписании и т. д. | | | | "interface" Collection
"interface" List | Упорядоченная коллекция (иногда называется последовательностью). Может содержать одинаковые элементы. Используя список, можно точно сказать где какой элемент расположен и обратиться к нему по его целочисленному индексу. |  |  |  | "interface" Collection
"interface" Queue |  Коллекция, используемая для хранения элементов в определенной последовательности перед их обработкой. Вдобавок к базовым методам Коллекции, очередь предлагает дополнительные методы вставки, извлечения и проверки. |  |  |  | "interface" Collection
HashSet | Неупорядоченная коллекция, исключающая дубликаты. Содержит элементы в хэш-таблице. Название HashSet,происходит от понятия хэш-функция. Хэш-функция — это функция, сужающая множество значений объекта до некоторого подмножества целых чисел. Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов, заносимых в коллекцию. | O(I) | O(I) | Используется в том случае, если нет повторяющихся значений.  | "interface" Set
LinkedHashSet | Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор. | O(I) | O(I) | Используется в том случае, если нет повторяющихся значений и важен порядок ввода. | "interface" Set
TreeSet | Класс TreeSet создаёт коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию. | O(log n) | O(log n) | Используется только в том случае, когда важно наличие сортировки. | "interface" Set
ArrayList | Индексированная динамически расширяющая и сокращающая последовательность.  ArrayList может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null. | O(I) | O(I) | Его удобно применять в тех случаях, когда не известен точный размера массива.  | "interface" List
Vector | Класс вектор  реализуется расширяемым массивом объектов. Как массив, он содержит компоненты, которые могут быть доступны с помощью целочисленного индекса. Тем не менее, размер вектора может увеличивать или уменьшать по мере необходимости, чтобы приспособить добавление и удаление элементов после  создания вектора. В отличие  от ArrayList, класс Vector синхронизирован и за счет этого он более долгий. | - | - | Каждый вектор пытается оптимизировать управление системами хранения, поддерживая способность и мощность прироста .  Приложение может увеличить пропускную способность вектора перед вставкой большое количество компонентов; это уменьшает количество дополнительных перераспределения. | "interface" List
LinkedList | Упорядоченная последовательность, допускающая эффективную вставку и удаление на любой позиции. Реализация связанных списков из списка и DEQUE интерфейсов. Имеет больше операций, чем ArrayList, а значит более сложный и требуюет больше памяти.  | O(n) | O(I) |  | "interface" List, "interface" Queue
PriorityQueue | В общем случае приоритетная очередь - это структура данных, которая хранит набор пар (ключ - значение) и поддерживает следующие операции:1) Object min();Возвращает значение элемента с минимальным ключом.2) void insert(Comparable key, Object value); Вставляет в очередь пару (key - value). 3) void removeMin(); Удаляет элемент с минимальным ключом. | O(I) | O(log n) |  Коллекция, позволяющает эффективно удалять наименьший элемент. Одно из самых важных ее применений - алгоритм Дейкстры. | "interface" Queue
"Interface" Map | Интерфейс map обеспечивает три коллекции сбора , которые позволяют содержание map's, чтобы рассматриваться как набор ключей, набора значений, или набор отображений ключей-значений. Порядок в map определяется как порядок, при котором итераторы на представлениях сбора map возвращаются их элементы. Некоторые реализации map, как TreeMap class, дают конкретные гарантии в отношении их порядка; другие, как в HashMap класса, нет. |  |  |  | 
"Interface" SortedMap | Map, которая дополнительно обеспечивает полное упорядочение его ключей. Карта, упорядоченных по естественным порядком его ключей или с помощью компаратора , как правило, предлагаемые в отсортированном время создания Map. Этот порядок находит отражение при переборе над видом сбора отсортированного карты.  |  |  |  | "Interface" Map
Hashtable | Hashtable - это реализация хэш-таблицы, элементами которой являются пары ключ-значение. Ключом и значением может быть любой не null объект.  Внутренняя структура HashTable представляет собой массив ссылок на объекты типа Entry. Объект Entry содержит хэш-код ключа, ключ, значение и ссылку на следующий элемент, таким образом образуется цепочка элементов типа Entry - bucket. Является синхронизированной. Из-за этой особенности у неё имеются существенные проблемы с производительностью | - | - |  | "Interface" Map
LinkedHashMap | Это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами. Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция.  | O(I) | O(I) | Этот метод особенно полезен, если модуль принимает Map на входе, его  копии, и поздно возвращает результаты, порядок которых определяется через копии.  | "Interface" Map
HashMap | Класс HashMap использует хеш-таблицу для хранения карточки, обеспечивая быстрое время выполнения запросов get() и put() при больших наборах. Класс реализует интерфейс Map (хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. При этом все ключи обязательно должны быть уникальны, а значения могут повторяться. Данная реализация не гарантирует порядка элементов. | O(I) | O(I) | Используется, когда необходима максимально большая скорость выборки, а порядок хранения его элементов не важен. | "Interface" Map
TreeMap | Реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, которые указывается в качестве параметра при создании объекта TreeMap. | O(log n) | O(log n) | Когда необходимо хранить ключи отсортированными по возрастанию. | "Interface" SortedMap